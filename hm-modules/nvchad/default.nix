{
  config,
  lib,
  pkgs,
  ...
}:
with lib; let
  cfg = config.programs.nvchad;
  chadRcOptions = types.attrs; # TODO: modularize chadRc
in {
  options.programs.nvchad = {
    enable = mkEnableOption "NvChad";
    package = mkOption {
      type = types.package;
      default = pkgs.nvchad;
      description = "Package for NvChad basic configuration.";
    };
    nvimPackage = mkOption {
      type = types.package;
      default = pkgs.neovim-unwrapped;
      description = "Neovim Package to use";
    };
    finalPackage = mkOption {
      type = types.package;
      readOnly = true;
      description = "Resulting NvChad configuration.";
    };
    settings = mkOption {
      type = chadRcOptions;
      default = {};
      description = "User configuration for NvChad.";
    };
    extraPackages = mkOption {
      type = types.listOf types.package;
      default = [];
      description = "Extra packages for NvChad.";
    };
  };
  config = mkIf cfg.enable {
    home.packages = [cfg.finalPackage];
    programs.nvchad.finalPackage = pkgs.nvchadUtils.wrapNvchad cfg.package {
      inherit (cfg) extraPackages;
      inherit (pkgs) gcc gnumake neovimUtils ripgrep;
      neovim = cfg.nvimPackage;
      wrapNeovim = pkgs.wrapNeovimUnstable;
      custom = pkgs.symlinkJoin {
        name = "nvchad-custom";
        paths = [
          (pkgs.writeTextDir "lua/custom/chadrc.lua" ''
            -- Generated by Home Manager.
            return ${lib.generators.toLua {} (cfg.settings
              // {
                lazy_nvim = {
                  performance.rtp.reset = false;
                  performance.reset_packpath = false;
                };
              })}
          '')
          (pkgs.writeTextDir "lua/custom/init.lua" ''
            -- Generated by Home Manager.
          '')
        ];
      };
    };
  };
}
